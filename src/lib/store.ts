// src/store/useStore.ts
import { create } from 'zustand'
import { persist, createJSONStorage } from 'zustand/middleware'
import type { StoreState, PlaylistProject, SongInfo } from '../types'

const initialArtists: string[] = [
  // Beyond Wonderland 2025 lineup (artist names)
  "Ahee", "AMP", "Andy C", "Barely Alive", "Bassrush Experience",
  "Carola", "Chris Lorenzo", "CHYL", "Combine", "Eli Brown",
  "Friction", "Illenium", "Insomniac Records", "INZO", "Jackie Hollander",
  "Layton Giordani", "Level Up", "Lilly Palmer", "Loud Luxury", "Maddix",
  "Me N Ü", "MYSTRVS", "San Pacho", "SLANDER", "SQWAD", "Steller",
  "Timmy Trumpet", "Tita Lau", "Tony H", "Walker & Royce", "Zomboy",
  "Alex Wann", "AMÉMÉ", "Audien", "Canabliss", "Chase & Status",
  "Cloonee", "Culture Shock", "Discovery Project", "DJ Snake", "DoBadlyy",
  "Ghastly presents Ghengar", "HoneyLuv", "Hugel", "Infekt", "It's Murph",
  "Koister", "LP Giobbi", "MPH", "NGHTMRE", "OG Nixin", "Peekaboo",
  "Said The Sky", "Sara Landry", "Shanghai Doom", "Subtronics", "Tom & Collins",
  "Trace", "Trivecta", "Wolfstax"
]

const defaultProject: PlaylistProject = {
  title: "Beyond Wonderland 2025 Playlist",
  description: "Autogenerated playlist for Beyond Wonderland at The Gorge 2025",
  playlistId: undefined,
  artists: initialArtists.map(name => ({
    name,
    confirmed: false,
    songs: []
  })),
  combinedSongs: []
}

export const useStore = create<StoreState>()(
  persist(
    (set, get) => ({

      // Initial state
      isAuthenticated: false,
      projects: [ defaultProject ],
      currentProjectIndex: 0,
      isLoading: false,
      error: null,

      // Actions to mutate state
      setAuthenticated: (isAuthenticated) => set({ isAuthenticated }),
      addProject: (project) => set(state => ({ projects: [...state.projects, project] })),
      setCurrentProject: (index) => set({ currentProjectIndex: index }),


      
      confirmArtist: (artistName, spotifyData) => {
        const state = get()
        const project = state.projects[state.currentProjectIndex]
        const updatedArtists = project.artists.map(artist => {
          if (artist.name === artistName) {
            return {
              ...artist,
              confirmed: true,
              spotifyId: spotifyData.id,
              spotifyData
            }
          }
          return artist
        })
        project.artists = updatedArtists
        set({ projects: [ ...state.projects ] })
      },
      
      undoArtist: (artistName) => {
        const state = get()
        const project = state.projects[state.currentProjectIndex]
        project.artists = project.artists.map(artist =>
          artist.name === artistName 
            ? { ...artist, confirmed: false, spotifyId: undefined, spotifyData: undefined, songs: [] }
            : artist
        )
        // Also remove any songs from this artist from combinedSongs:
        project.combinedSongs = project.combinedSongs.filter(song => song.artist !== artistName)
        set({ projects: [ ...state.projects ] })
      },

      addSongs: (artistName, songs) => {
        const state = get()
        const project = state.projects[state.currentProjectIndex]
        // Mark duplicates and add to combined list
        const newSongs: SongInfo[] = []
        songs.forEach(song => {
          const alreadyExists = project.combinedSongs.some(s => s.id === song.id)
          if (alreadyExists) {
            song.duplicate = true
          }
          newSongs.push(song)
          // If not already in combined list, add it
          if (!alreadyExists) {
            project.combinedSongs.push(song)
          }
        })
        // Update the artist's own song list
        project.artists = project.artists.map(artist =>
          artist.name === artistName ? { ...artist, songs: newSongs } : artist
        )
        set({ projects: [ ...state.projects ] })
      },

      removeSong: (songId) => {
        const state = get()
        const project = state.projects[state.currentProjectIndex]
        // Remove from combined list
        project.combinedSongs = project.combinedSongs.filter(s => s.id !== songId)
        // Also remove from the specific artist's songs list
        project.artists.forEach(artist => {
          artist.songs = artist.songs.filter(s => s.id !== songId)
        })
        set({ projects: [ ...state.projects ] })
      },

      moveSong: (fromIndex, toIndex) => {
        const state = get()
        const project = state.projects[state.currentProjectIndex]
        const list = project.combinedSongs
        if (fromIndex < 0 || toIndex < 0 || fromIndex >= list.length || toIndex >= list.length) return
        // simple swap algorithm
        const updatedList = [...list]
        const [moved] = updatedList.splice(fromIndex, 1)
        updatedList.splice(toIndex, 0, moved)
        project.combinedSongs = updatedList
        set({ projects: [ ...state.projects ] })
      },

      setError: (err) => set({ error: err }),

      setPlaylistId: (playlistId) => {
        const state = get()
        const project = state.projects[state.currentProjectIndex]
        project.playlistId = playlistId
        set({ projects: [ ...state.projects ] })
      },

      addArtistToProject: (artistName) => {
        const state = get()
        const project = state.projects[state.currentProjectIndex]
        
        // Check if artist already exists
        if (project.artists.some(a => a.name.toLowerCase() === artistName.toLowerCase())) {
          return false
        }

        // Add new artist
        project.artists.push({
          name: artistName,
          confirmed: false,
          songs: []
        })

        set({ projects: [...state.projects] })
        return true
      },

      removeArtistFromProject: (artistName) => {
        const state = get()
        const project = state.projects[state.currentProjectIndex]
        
        // Remove artist and their songs
        project.artists = project.artists.filter(a => a.name !== artistName)
        project.combinedSongs = project.combinedSongs.filter(s => s.artist !== artistName)
        
        set({ projects: [...state.projects] })
      }
    }),
    {
      name: "playlist-creator-storage", // localStorage key
      storage: createJSONStorage(() => localStorage),
      // Optionally, partialize state to persist only projects (and not ephemeral loading state, etc.)
      partialize: (state) => ({
        projects: state.projects,
        currentProjectIndex: state.currentProjectIndex
      })
    }
  )
)